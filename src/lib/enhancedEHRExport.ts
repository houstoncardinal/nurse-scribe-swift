interface EHRSystem {
  id: string;
  name: string;
  format: string;
  template: string;
  instructions: string;
}

interface ExportOptions {
  includeTimestamp: boolean;
  includeSignature: boolean;
  includeAppBranding: boolean;
  format: 'ehr' | 'pdf' | 'txt' | 'docx';
  template: string;
  customHeader?: string;
  customFooter?: string;
}

interface ExportMetadata {
  generatedAt: string;
  generatedBy: string;
  appVersion: string;
  template: string;
  wordCount: number;
  estimatedTime: number;
}

interface NoteContent {
  [key: string]: string;
}

class EnhancedEHRExportService {
  private ehrSystems: EHRSystem[] = [
    {
      id: 'epic',
      name: 'Epic MyChart',
      format: 'structured',
      template: 'epic_nursing_note',
      instructions: 'Copy and paste directly into Epic nursing note fields. Ensure proper section headers are maintained.'
    },
    {
      id: 'cerner',
      name: 'Cerner PowerChart',
      format: 'structured',
      template: 'cerner_nursing_note',
      instructions: 'Paste into Cerner nursing documentation. Use structured format for best compatibility.'
    },
    {
      id: 'allscripts',
      name: 'Allscripts Sunrise',
      format: 'structured',
      template: 'allscripts_note',
      instructions: 'Copy content into Allscripts nursing note template. Maintain section formatting.'
    },
    {
      id: 'meditech',
      name: 'Meditech Expanse',
      format: 'structured',
      template: 'meditech_note',
      instructions: 'Paste into Meditech nursing documentation system. Use provided format for optimal display.'
    },
    {
      id: 'generic',
      name: 'Generic EHR',
      format: 'text',
      template: 'generic_note',
      instructions: 'Universal format compatible with most EHR systems. Copy and paste into any nursing note field.'
    }
  ];

  getEHRSystems(): EHRSystem[] {
    return this.ehrSystems;
  }

  getDefaultOptions(): ExportOptions {
    return {
      includeTimestamp: true,
      includeSignature: true,
      includeAppBranding: true,
      format: 'ehr',
      template: 'SOAP'
    };
  }

  formatForEHR(ehrSystemId: string, noteContent: NoteContent, options: ExportOptions): string {
    const ehrSystem = this.ehrSystems.find(system => system.id === ehrSystemId);
    if (!ehrSystem) {
      throw new Error(`EHR system ${ehrSystemId} not found`);
    }

    const timestamp = new Date().toLocaleString();
    const metadata = this.getMetadata(noteContent, options);
    
    let formattedContent = '';

    // Add header if requested
    if (options.includeTimestamp || options.includeAppBranding) {
      formattedContent += this.generateHeader(metadata, options);
    }

    // Format content based on EHR system
    switch (ehrSystemId) {
      case 'epic':
        formattedContent += this.formatForEpic(noteContent, options);
        break;
      case 'cerner':
        formattedContent += this.formatForCerner(noteContent, options);
        break;
      case 'allscripts':
        formattedContent += this.formatForAllscripts(noteContent, options);
        break;
      case 'meditech':
        formattedContent += this.formatForMeditech(noteContent, options);
        break;
      default:
        formattedContent += this.formatGeneric(noteContent, options);
    }

    // Add footer if requested
    if (options.includeSignature) {
      formattedContent += this.generateFooter(options);
    }

    return formattedContent;
  }

  private generateHeader(metadata: ExportMetadata, options: ExportOptions): string {
    let header = '';
    
    if (options.includeTimestamp) {
      header += `Generated: ${metadata.generatedAt}\n`;
    }
    
    if (options.includeAppBranding) {
      header += `Generated by: NurseScribe AI v${metadata.appVersion}\n`;
    }
    
    if (options.customHeader) {
      header += `${options.customHeader}\n`;
    }
    
    header += `${'='.repeat(50)}\n\n`;
    
    return header;
  }

  private generateFooter(options: ExportOptions): string {
    let footer = '\n';
    
    if (options.customFooter) {
      footer += `${options.customFooter}\n`;
    } else {
      footer += `---\n`;
      footer += `Documentation completed using NurseScribe AI\n`;
      footer += `HIPAA Compliant • Local Processing Only\n`;
    }
    
    return footer;
  }

  private formatForEpic(noteContent: NoteContent, options: ExportOptions): string {
    const epicFormat = {
      'SOAP': {
        'S': noteContent.subjective || noteContent.assessment || 'No subjective data recorded.',
        'O': noteContent.objective || noteContent.interventions || 'No objective data recorded.',
        'A': noteContent.assessment || noteContent.assessment || 'No assessment recorded.',
        'P': noteContent.plan || noteContent.plan || 'No plan recorded.'
      },
      'SBAR': {
        'S': noteContent.situation || noteContent.assessment || 'No situation recorded.',
        'B': noteContent.background || noteContent.interventions || 'No background recorded.',
        'A': noteContent.assessment || noteContent.assessment || 'No assessment recorded.',
        'R': noteContent.recommendation || noteContent.plan || 'No recommendation recorded.'
      },
      'PIE': {
        'P': noteContent.problem || noteContent.assessment || 'No problem identified.',
        'I': noteContent.intervention || noteContent.interventions || 'No intervention recorded.',
        'E': noteContent.evaluation || noteContent.plan || 'No evaluation recorded.'
      },
      'DAR': {
        'D': noteContent.data || noteContent.assessment || 'No data recorded.',
        'A': noteContent.action || noteContent.interventions || 'No action recorded.',
        'R': noteContent.response || noteContent.plan || 'No response recorded.'
      }
    };

    const format = epicFormat[options.template] || epicFormat['SOAP'];
    let content = '';

    Object.entries(format).forEach(([section, text]) => {
      content += `${section}: ${text}\n\n`;
    });

    return content;
  }

  private formatForCerner(noteContent: NoteContent, options: ExportOptions): string {
    // Cerner uses a more structured format
    let content = `NURSING DOCUMENTATION - ${options.template}\n\n`;
    
    const sections = this.getSectionsForTemplate(options.template, noteContent);
    
    sections.forEach(({ title, content: sectionContent }) => {
      content += `${title.toUpperCase()}:\n`;
      content += `${sectionContent}\n\n`;
    });

    return content;
  }

  private formatForAllscripts(noteContent: NoteContent, options: ExportOptions): string {
    // Allscripts prefers a narrative format with clear section breaks
    let content = `Nursing Note - ${options.template} Format\n`;
    content += `${'─'.repeat(40)}\n\n`;
    
    const sections = this.getSectionsForTemplate(options.template, noteContent);
    
    sections.forEach(({ title, content: sectionContent }) => {
      content += `• ${title}: ${sectionContent}\n\n`;
    });

    return content;
  }

  private formatForMeditech(noteContent: NoteContent, options: ExportOptions): string {
    // Meditech uses a specific formatting structure
    let content = `[NURSING NOTE]\n`;
    content += `Template: ${options.template}\n`;
    content += `Date/Time: ${new Date().toLocaleString()}\n\n`;
    
    const sections = this.getSectionsForTemplate(options.template, noteContent);
    
    sections.forEach(({ title, content: sectionContent }, index) => {
      content += `${index + 1}. ${title.toUpperCase()}\n`;
      content += `   ${sectionContent}\n\n`;
    });

    return content;
  }

  private formatGeneric(noteContent: NoteContent, options: ExportOptions): string {
    let content = `NURSING NOTE - ${options.template}\n`;
    content += `${'='.repeat(30)}\n\n`;
    
    const sections = this.getSectionsForTemplate(options.template, noteContent);
    
    sections.forEach(({ title, content: sectionContent }) => {
      content += `${title}:\n`;
      content += `${sectionContent}\n\n`;
    });

    return content;
  }

  private getSectionsForTemplate(template: string, noteContent: NoteContent) {
    switch (template) {
      case 'SOAP':
        return [
          { title: 'Subjective', content: noteContent.subjective || noteContent.assessment || 'No subjective data recorded.' },
          { title: 'Objective', content: noteContent.objective || noteContent.interventions || 'No objective data recorded.' },
          { title: 'Assessment', content: noteContent.assessment || noteContent.assessment || 'No assessment recorded.' },
          { title: 'Plan', content: noteContent.plan || noteContent.plan || 'No plan recorded.' }
        ];
      case 'SBAR':
        return [
          { title: 'Situation', content: noteContent.situation || noteContent.assessment || 'No situation recorded.' },
          { title: 'Background', content: noteContent.background || noteContent.interventions || 'No background recorded.' },
          { title: 'Assessment', content: noteContent.assessment || noteContent.assessment || 'No assessment recorded.' },
          { title: 'Recommendation', content: noteContent.recommendation || noteContent.plan || 'No recommendation recorded.' }
        ];
      case 'PIE':
        return [
          { title: 'Problem', content: noteContent.problem || noteContent.assessment || 'No problem identified.' },
          { title: 'Intervention', content: noteContent.intervention || noteContent.interventions || 'No intervention recorded.' },
          { title: 'Evaluation', content: noteContent.evaluation || noteContent.plan || 'No evaluation recorded.' }
        ];
      case 'DAR':
        return [
          { title: 'Data', content: noteContent.data || noteContent.assessment || 'No data recorded.' },
          { title: 'Action', content: noteContent.action || noteContent.interventions || 'No action recorded.' },
          { title: 'Response', content: noteContent.response || noteContent.plan || 'No response recorded.' }
        ];
      default:
        return [
          { title: 'Assessment', content: noteContent.assessment || 'No assessment recorded.' },
          { title: 'Interventions', content: noteContent.interventions || 'No interventions recorded.' },
          { title: 'Plan', content: noteContent.plan || 'No plan recorded.' }
        ];
    }
  }

  private getMetadata(noteContent: NoteContent, options: ExportOptions): ExportMetadata {
    const allContent = Object.values(noteContent).join(' ');
    const wordCount = allContent.split(/\s+/).length;
    
    return {
      generatedAt: new Date().toLocaleString(),
      generatedBy: 'NurseScribe AI',
      appVersion: '1.0.0',
      template: options.template,
      wordCount: wordCount,
      estimatedTime: Math.max(1, Math.ceil(wordCount / 250)) // Estimate minutes based on 250 words per minute
    };
  }

  async copyToClipboard(content: string): Promise<boolean> {
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(content);
        return true;
      } else {
        // Fallback for older browsers or non-secure contexts
        const textArea = document.createElement('textarea');
        textArea.value = content;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        const success = document.execCommand('copy');
        document.body.removeChild(textArea);
        return success;
      }
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      return false;
    }
  }

  async downloadAsText(content: string, filename?: string): Promise<boolean> {
    try {
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      
      link.href = url;
      link.download = filename || `nursing_note_${Date.now()}.txt`;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
      return true;
    } catch (error) {
      console.error('Failed to download text file:', error);
      return false;
    }
  }

  async exportAsPDF(content: string, options: ExportOptions): Promise<boolean> {
    try {
      // Dynamic import of jsPDF to avoid bundle size issues
      const { jsPDF } = await import('jspdf');
      
      const doc = new jsPDF();
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 20;
      const maxWidth = pageWidth - (margin * 2);
      
      // Set font
      doc.setFont('helvetica');
      doc.setFontSize(12);
      
      // Add title
      doc.setFontSize(16);
      doc.setFont('helvetica', 'bold');
      doc.text('NURSING NOTE', margin, margin + 10);
      
      // Add template info
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text(`Template: ${options.template}`, margin, margin + 20);
      doc.text(`Generated: ${new Date().toLocaleString()}`, margin, margin + 25);
      doc.text(`Generated by: NurseScribe AI`, margin, margin + 30);
      
      // Add separator line
      doc.setLineWidth(0.5);
      doc.line(margin, margin + 35, pageWidth - margin, margin + 35);
      
      // Add content
      doc.setFontSize(11);
      const contentLines = doc.splitTextToSize(content, maxWidth);
      
      let yPosition = margin + 45;
      const lineHeight = 7;
      
      for (let i = 0; i < contentLines.length; i++) {
        if (yPosition + lineHeight > pageHeight - margin) {
          doc.addPage();
          yPosition = margin;
        }
        
        doc.text(contentLines[i], margin, yPosition);
        yPosition += lineHeight;
      }
      
      // Add footer
      const footerY = pageHeight - 10;
      doc.setFontSize(8);
      doc.setFont('helvetica', 'italic');
      doc.text('Generated by NurseScribe AI - HIPAA Compliant', margin, footerY);
      doc.text('Local Processing Only', pageWidth - margin - 40, footerY);
      
      // Save the PDF
      const filename = `nursing_note_${options.template}_${Date.now()}.pdf`;
      doc.save(filename);
      
      return true;
    } catch (error) {
      console.error('Failed to generate PDF:', error);
      return false;
    }
  }

  async exportAsDocx(content: string, options: ExportOptions): Promise<boolean> {
    try {
      // Dynamic import of docx to avoid bundle size issues
      const { Document, Packer, Paragraph, TextRun, HeadingLevel } = await import('docx');
      
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            new Paragraph({
              text: "NURSING NOTE",
              heading: HeadingLevel.HEADING_1,
            }),
            new Paragraph({
              text: `Template: ${options.template}`,
              children: [new TextRun({ text: `Template: ${options.template}`, size: 20 })],
            }),
            new Paragraph({
              text: `Generated: ${new Date().toLocaleString()}`,
              children: [new TextRun({ text: `Generated: ${new Date().toLocaleString()}`, size: 20 })],
            }),
            new Paragraph({
              text: `Generated by: NurseScribe AI`,
              children: [new TextRun({ text: `Generated by: NurseScribe AI`, size: 20 })],
            }),
            new Paragraph({
              text: "",
            }),
            new Paragraph({
              text: content,
              children: [new TextRun({ text: content, size: 24 })],
            }),
          ],
        }],
      });
      
      const buffer = await Packer.toBlob(doc);
      const url = URL.createObjectURL(buffer);
      const link = document.createElement('a');
      
      link.href = url;
      link.download = `nursing_note_${options.template}_${Date.now()}.docx`;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
      return true;
    } catch (error) {
      console.error('Failed to generate DOCX:', error);
      return false;
    }
  }

  async saveToLocalStorage(content: string, noteContent: NoteContent, options: ExportOptions): Promise<boolean> {
    try {
      const noteData = {
        id: Date.now(),
        template: options.template,
        content: noteContent,
        formattedContent: content,
        timestamp: new Date().toISOString(),
        metadata: this.getMetadata(noteContent, options),
        exported: true
      };
      
      const savedNotes = JSON.parse(localStorage.getItem('nursescribe_notes') || '[]');
      savedNotes.push(noteData);
      localStorage.setItem('nursescribe_notes', JSON.stringify(savedNotes));
      
      return true;
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
      return false;
    }
  }
}

export const enhancedEHRExportService = new EnhancedEHRExportService();
